<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on biotope monologue</title>
		<link>https://mijinko17.github.io/hoge/posts/</link>
		<description>Recent content in Posts on biotope monologue</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>jp</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Thu, 07 May 2020 10:23:10 +0900</lastBuildDate>
		<atom:link href="https://mijinko17.github.io/hoge/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Mujin Programming Challenge 2018 D うほょじご</title>
			<link>https://mijinko17.github.io/hoge/posts/mujin_pc_2018_d/</link>
			<pubDate>Thu, 07 May 2020 10:23:10 +0900</pubDate>
			
			<guid>https://mijinko17.github.io/hoge/posts/mujin_pc_2018_d/</guid>
			<description>色々解法を思いついたので書いてみる。
問題
概要 $X:=\{\ 0$以上$1000$未満の整数$\ \}$ とする。
正の整数 $n$、$m&amp;lt;1000$ が与えられる。問題文で定義される $f:X \times X\rightarrow X \times X$ について、次を満たす $(p,q) \in X \times X$ の個数を求めよ。
 $1 \leq p \leq n$, $1 \leq q \leq m$ $(p,q)$ に $f$ を繰り返し施しても第一成分、第二成分いずれも$0$にならない。  解法 1(解説の方法) $f$ を繰り返し施したとき第一成分、第二成分どちらかが 0 になるものを数えてもよい。これを数えるには $X \times X$ の元全体を頂点とするグラフに操作 $f$ から誘導される有向辺を張り、その辺に沿って移動したときにいつか $(0,k)$ か $(k,0)$ になるものを数えればいい。これは $f$ から誘導される辺とは逆向きの辺を張って $(0,k)$ と $(k,0)$ から BFS をすれば調べられる。
実装上は$p$、$q$ いずれかが 0 のとき$f(p,q)=(0,0)$と定義して$(0,0)$から BFS するのが楽。
解法 2 (union-find) $p$、$q$ いずれかが 0 のとき $f(p,q)=(0,0)$ としておく。</description>
			<content type="html"><![CDATA[<p>色々解法を思いついたので書いてみる。</p>
<p><a href="https://atcoder.jp/contests/mujin-pc-2018/tasks/mujin_pc_2018_d" target="_blank">問題</a></p>
<h1 id="概要">概要</h1>
<p>$X:=\{\ 0$以上$1000$未満の整数$\ \}$ とする。</p>
<p>正の整数 $n$、$m&lt;1000$ が与えられる。問題文で定義される $f:X \times X\rightarrow X \times X$ について、次を満たす $(p,q) \in X \times X$ の個数を求めよ。</p>
<ul>
<li>$1 \leq p \leq n$, $1 \leq q \leq m$</li>
<li>$(p,q)$ に $f$ を繰り返し施しても第一成分、第二成分いずれも$0$にならない。</li>
</ul>
<h1 id="解法-1解説の方法">解法 1(解説の方法)</h1>
<p>$f$ を繰り返し施したとき第一成分、第二成分どちらかが 0 になるものを数えてもよい。これを数えるには $X \times X$ の元全体を頂点とするグラフに操作 $f$ から誘導される有向辺を張り、その辺に沿って移動したときにいつか $(0,k)$ か $(k,0)$ になるものを数えればいい。これは $f$ から誘導される辺とは逆向きの辺を張って $(0,k)$ と $(k,0)$ から BFS をすれば調べられる。</p>
<p>実装上は$p$、$q$ いずれかが 0 のとき$f(p,q)=(0,0)$と定義して$(0,0)$から BFS するのが楽。</p>
<h1 id="解法-2-union-find">解法 2 (union-find)</h1>
<p>$p$、$q$ いずれかが 0 のとき $f(p,q)=(0,0)$ としておく。</p>
<p>この問題は次のように言い換えられる。</p>
<ul>
<li>$X \times X$の元を次の 2 つのグループに分けよ。
<ol>
<li>$f$ を繰り返し施しても $(0,0)$ にならない。</li>
<li>$f$ を繰り返し施したときいつか $(0, 0)$ になる。</li>
</ol>
</li>
</ul>
<p>次が成り立つ。</p>
<p><strong>主張 1</strong></p>
<ul>
<li>任意の$ (p,q) \in X \times X$ について、$(p,q)$ と $f(p,q)$ は同じグループに属する。</li>
<li>$(p&rsquo;,q&rsquo;)$ が 2 のグループに属することは、全ての $(p,q)$ について $(p,q)$ と $f(p,q)$ を union-find で繋いだときに $(p&rsquo;,q&rsquo;)$ が $(0,0)$ と同じグループになることと同値である。</li>
</ul>
<p>よって $(p,q)$ と $f(p,q)$ を union-find で繋いでいき、$(0,0)$ と同値になるものを数えればいい。</p>
<p><a href="https://atcoder.jp/contests/mujin-pc-2018/submissions/12905331" target="_blank">ソースコード</a></p>
<h1 id="解法-3ダブリング">解法 3(ダブリング)</h1>
<p>問題文で問われているものの個数を直接数えることもできる。ここでも $p$、$q$ いずれかが 0 のとき$f(p,q)=(0,0)$ としておく。また $f$ の $k$ 回繰り返しを $f^k$ で表記する。</p>
<p>次が成り立つ。</p>
<p><strong>主張 2</strong></p>
<ul>
<li>$(p,q)$ に $f$ を何回施しても $(0,0)$ にならないことは、 $(p,q)$ に $f$ を 1000000($=|X \times X|$)回施しても $(0,0)$ にならないことと同値である。</li>
</ul>
<p>よって各 $(p,q)$ について $f^{1000000}(p,q)$ を計算できればいいが、シンプルな方法では間に合わない。これはダブリングを使うことで $f^k$ を $O(\log\ k)$ で計算できる。具体的には、</p>
<ol>
<li>$\text{doubling}[(p,q)][i]=f^{2^i}(p,q)$ となるようにテーブルを作成できればいい。</li>
<li>愚直な計算で$\text{doubling}[(p,q)][0]$ は埋められる。</li>
<li>$\text{doubling}[(p,q)][i]=\text{doubling}[\text{doubling}[(p,q)][i-1]][i-1]$ とすればテーブルを高速に埋められる。</li>
</ol>
<p>とすれば良い。</p>
<p><a href="https://atcoder.jp/contests/mujin-pc-2018/submissions/12915255" target="_blank">ソースコード</a></p>
]]></content>
		</item>
		
		<item>
			<title>AtCoder青になったのでイキる</title>
			<link>https://mijinko17.github.io/hoge/posts/into_blue/</link>
			<pubDate>Thu, 30 Apr 2020 21:30:34 +0900</pubDate>
			
			<guid>https://mijinko17.github.io/hoge/posts/into_blue/</guid>
			<description>先日の ABC で念願の青コーダーになりました。
黄パフォで青に入れて気持ちよかったです。
この記事では青になるまでにやってきたことを書いてイキっていこうと思います。
何をした   アルゴリズム、データ構造の勉強をした(去年 8 月〜)
学んだアルゴリズムはだいたいここを見れば分かります。
青になった時点でのライブラリ
アルゴリズム習得の目的は次の 2 つです。
 解ける問題を増やす 知識不足で解けないかもしれない、という不安を払拭する  2 つ目が重要です。問題を解く上で「今の自分の知識では無理かも……」という精神状態になってしまうと解ける問題も解けません。これを回避したければ目にしがちなアルゴリズムは全て習得してしまうべきです。自分はこの考えのもとに緑の頃から遅延セグ木や FFT の勉強をしていました。
たまに twitter で「foo 色に bar アルゴリズムは必要ない！！」と主張してる人を見かけますが、上記の理由からアルゴリズムの学習はどのタイミングでやっても意味があると思っています。
具体的な学習方法についてですが、友人の友人が github で公開している競プロライブラリにあるアルゴリズムをググり、けんちょんさんの記事で勉強することが多かったです。
  ライブラリを整備した(去年 9 月〜)
目的は以下の 2 つです。
 ライブラリをぺたぺた貼って問題を瞬殺できるようにするため。 実装力の低さをカバーするため  これについてあまり語ることはありません。ちなみにライブラリはスニペットですぐ貼れるようにすると楽です。
  実験をするようにした(去年 9 月〜)
きっかけはつよつよの友人が凄まじい diff の問題を実験しまくって解くのを見たことだったと思います。当時水 diff すら怪しかった自分ですが、彼を真似して実験を大切にするようにしたら青 diff も解けるようになりました。
記述が少なくてやる気なさげに見えるかもしれませんが、自分が青になる上で一番効いたのは実験だと思ってます。実験は頭にイイ！！
  山を張った
「自分にはできない」という自信のなさを払拭する一度の成功体験が欲しくて山を張ったことがあります。具体的には以下の 2 回です。
  ABC の E を本番で解くためにグラフの問題に集中して取り組んだ(去年 10 月)</description>
			<content type="html"><![CDATA[<p>先日の ABC で念願の青コーダーになりました。</p>
<p><img src="/hoge/rating_graph.png" alt="rating"></p>
<p><img src="/hoge/performance_graph.png" alt="performance"></p>
<p><img src="/hoge/problems.png" alt="performance"></p>
<p>黄パフォで青に入れて気持ちよかったです。</p>
<p>この記事では青になるまでにやってきたことを書いてイキっていこうと思います。</p>
<h1 id="何をした">何をした</h1>
<ol>
<li>
<p>アルゴリズム、データ構造の勉強をした(去年 8 月〜)</p>
<p>学んだアルゴリズムはだいたいここを見れば分かります。</p>
<p><a href="https://github.com/mijinko17/dotfiles/blob/2ba084811ccb5e862c7deefa8c8ac0df886c31a1/.config/nvim/snippets/cpp.snip" target="_blank">青になった時点でのライブラリ</a></p>
<p>アルゴリズム習得の目的は次の 2 つです。</p>
<ul>
<li>解ける問題を増やす</li>
<li>知識不足で解けないかもしれない、という不安を払拭する</li>
</ul>
<p>2 つ目が重要です。問題を解く上で「今の自分の知識では無理かも……」という精神状態になってしまうと解ける問題も解けません。これを回避したければ目にしがちなアルゴリズムは全て習得してしまうべきです。自分はこの考えのもとに緑の頃から遅延セグ木や FFT の勉強をしていました。</p>
<p>たまに twitter で「foo 色に bar アルゴリズムは必要ない！！」と主張してる人を見かけますが、上記の理由からアルゴリズムの学習はどのタイミングでやっても意味があると思っています。</p>
<p>具体的な学習方法についてですが、友人の友人が github で公開している競プロライブラリにあるアルゴリズムをググり、けんちょんさんの記事で勉強することが多かったです。</p>
</li>
<li>
<p><a href="https://github.com/mijinko17/dotfiles/blob/2ba084811ccb5e862c7deefa8c8ac0df886c31a1/.config/nvim/snippets/cpp.snip" target="_blank">ライブラリ</a>を整備した(去年 9 月〜)</p>
<p>目的は以下の 2 つです。</p>
<ul>
<li>ライブラリをぺたぺた貼って問題を瞬殺できるようにするため。</li>
<li>実装力の低さをカバーするため</li>
</ul>
<p>これについてあまり語ることはありません。ちなみにライブラリはスニペットですぐ貼れるようにすると楽です。</p>
</li>
<li>
<p>実験をするようにした(去年 9 月〜)</p>
<p>きっかけはつよつよの友人が凄まじい diff の問題を実験しまくって解くのを見たことだったと思います。当時水 diff すら怪しかった自分ですが、彼を真似して実験を大切にするようにしたら青 diff も解けるようになりました。</p>
<p>記述が少なくてやる気なさげに見えるかもしれませんが、自分が青になる上で一番効いたのは実験だと思ってます。実験は頭にイイ！！</p>
</li>
<li>
<p>山を張った</p>
<p>「自分にはできない」という自信のなさを払拭する一度の成功体験が欲しくて山を張ったことがあります。具体的には以下の 2 回です。</p>
<ul>
<li>
<p>ABC の E を本番で解くためにグラフの問題に集中して取り組んだ(去年 10 月)</p>
<p>出題率の高いグラフに絞り、グラフなら絶対解ける自信がつくまで練習しました。練習を始めてから 2 週間ほどでグラフが出題され、初めて ABC-E をコンテスト中に AC することができました。</p>
</li>
<li>
<p>AGC041 の tourist 回に備えて tourist が writer をしている回の AGC を直前に解いた(去年 12 月)</p>
<p>こちらは 700 点以上を本番で解きたくてやりました。無事この回の B を AC できました。</p>
</li>
</ul>
<p>その後も ABC-E や 700 点以上の問題をコンテスト中に解けているので、この試みには一度の成功体験以上の意味があったと認識しています。</p>
<p>一度も達成したことのないことに向けて努力するのは精神的に辛いので、山を張って無理やり成功体験をもぎ取るのはありなんじゃないかと思います。</p>
</li>
<li>
<p>順位表を見る練習をした(去年 12 月〜)</p>
<p>正確には問題毎の AC 数をコンテスト中に確認する練習です。練習とは言っても単にコンテスト中に順位表を見るだけです。順位表の確認は自分の順位を直視することになり結構メンタルにくるので、回数を重ねて慣れるようにしていました。</p>
</li>
<li>
<p>区間、添字に関する考え方を徹底させた(今年 1 月〜)</p>
<p>いつも添字バグで泣いてる割には対策を全くしてないのはダサいなと思い、添字と真剣に向き合いました。具体的には以下の考え方を導入しました。</p>
<ul>
<li>添字 i は、(0-indexed での) i 番目の要素の左側にある仕切りだと思う。</li>
<li>区間(i,j)は、i と j の仕切りに挟まれた要素の集合と思う(これは実質的に半開区間と同じ)。</li>
<li>イテレータについても<a href="https://betrue12.hateblo.jp/entry/2019/12/04/000146">この記事</a>を参考に仕切りだと思う。</li>
<li><code>v</code> のイテレータ <code>itr</code> は<code>itr-v.begin()</code>で同じ仕切りに対応する添字に変換できることに注意する。</li>
</ul>
<p>これらの考え方に統一することで添字に関するバグがかなり減りました。特に <code>lower_bound</code>、<code>upper_bound</code> を使う問題でのミスが殆どなくなりました。この考えをそのまま他人に勧めるつもりはありませんが、添字の捉え方を何かしら統一させておくとバグを少しは減らせるかもしれません。</p>
</li>
</ol>
<h1 id="何をしなかった">何をしなかった</h1>
<ol>
<li>
<p>蟻本による精進</p>
<p>しなかったというよりはできませんでした。水 diff 以上が解けず悩んでいた時期に購入はしたのですが、結局ほとんど使ってません。理由としては以下が挙げられます。</p>
<ul>
<li>1 つの教材と向き合い続ける根気強さがなかった</li>
<li>紙の教材でプログラミングの勉強をするのは筋が悪い感じがした</li>
<li>AtCoder の問題で演習をしたかった</li>
</ul>
<p>1 つめの問題以外はけんちょんさんの AtCoder 版蟻本で解決するのでこちらを活用することが多かったです。これに限らず現在はネット上に競プロの記事がたくさんあるので、教材として蟻本にこだわる理由はないと感じています。</p>
</li>
<li>
<p>マクロの整備</p>
<p>マクロを使わなかった理由は以下の 2 つです。</p>
<ul>
<li>
<p>読みにくい</p>
<p>競プロ始めたての頃に <code>rep</code> やら <code>REP</code> やら <code>rrep</code> だらけのコードが読みにくすぎてブチ切れた経験から、マクロは使わないと心に決めています。</p>
</li>
<li>
<p>エディタ側の工夫で同様の恩恵を得られる</p>
<p>マクロを使わないので理解の浅い部分がありますが、マクロのメリットは以下の 2 点だと認識しています。</p>
<ol>
<li>for 文や <code>push_back</code> などを少ないキー操作で打てる</li>
<li>for 文の変数を変えるときに楽(3 箇所変えなくて良い)</li>
</ol>
<p>これらの効能は全て適切にツールを使うことで得られます(1 はスニペットと入力補完で、2 は lsp の rename 機能で)。わざわざマクロを使う必要はありません。長くなるのでこの辺で止めておきますが、入力の面倒臭さはエディタ側で解決すべき問題であるというのが持論です。</p>
</li>
</ul>
</li>
<li>
<p>バチャ、あさかつよるかつ</p>
<p>予め断っておくと、バチャ自体は有効な練習方法だと認識しています。バチャをしなかった理由は以下の 2 つです。</p>
<ul>
<li>本番以外の環境で 2 時間近く拘束されることに耐えられない</li>
<li>コドフォなどを含めれば rated のコンテストは十分にあり、そちらの方が優先度が高い</li>
</ul>
<p>現状のコンテスト数に満足できなくなるか、レート 2000 以上になって rated が少なくなってきたら取り組む可能性は十分にあります。</p>
</li>
<li>
<p>解説 AC</p>
<p>どんな問題も自力で AC したいので極力解説は見ません。それがいいのか悪いのかはちょっと分かりません。そろそろ記事書くの疲れてきました。</p>
</li>
<li>
<p>streak 繋ぎ</p>
<p>ものぐさな自分が毎日競プロするのは無理です。</p>
</li>
<li>
<p>NoSub</p>
<p>疲れてきたので、「制約と誓約」という言葉を紹介するにとどめます。</p>
</li>
</ol>
<h1 id="今後">今後</h1>
<p>正直に言うと黄色を目指すモチベーションは高くありません。なれる自信がありませんし、なれるのだとしても、そのための努力は黄色になれる喜びに見合わない膨大な量になるだろうからです。上を目指してガシガシ頑張ることはしばらくないでしょう。</p>
<p>もし本気で頑張るなら黄色になれるという自信を手に入れるところから始めると思います。けど何から手をつければいいのやら……。</p>
<p>しばらくは水堕ちしないように頑張ります。</p>
<h1 id="まとめ">まとめ</h1>
<p>記事の締め方が分からなくて他の人の色変記事を読んでいたのですが、普通は競プロを始めたきっかけとかにも触れたりするんですね。自分の始めたきっかけは「競プロのコンテストを理由に焼肉を断られた」です。</p>
<p>とりあえず箇条書きで書くといい感じらしいのでまとめます。</p>
<ul>
<li>実験は大事</li>
<li>解ける自信を持てるようにするのも大事</li>
<li>マクロはクソ</li>
<li>黄色は遠い</li>
</ul>
<p>最後までイキリ記事に付き合ってくださりありがとうございました。</p>
]]></content>
		</item>
		
		<item>
			<title>Macを買った時に設定したこと</title>
			<link>https://mijinko17.github.io/hoge/posts/mynewmac/</link>
			<pubDate>Sat, 29 Feb 2020 05:10:50 +0900</pubDate>
			
			<guid>https://mijinko17.github.io/hoge/posts/mynewmac/</guid>
			<description>dotfiles   brew のインスコ-&amp;gt;brew install git-&amp;gt;git clone-&amp;gt;brew bundle の流れ。ちなみに git 自体は元から入っていた。
  brew のインストールにめちゃ時間掛かってびっくりしてしまった。xcode も一緒に入れるらしくそこで時間吸われたっぽい。
  brew bundle も永遠に終わらず、バイトに行く前に回し始めておいたのだが帰ってきたらエラー終了していた。llvm にやたら時間が掛かっていたっぽい。
  neovim 概ね問題なかったが、pip で neovim の何かを入れるのを忘れていて deoplete に怒られてしまった。
mac のシステム環境設定   dock を右寄せ、自動的に非表示。使わないアプリを dock から消して iterm2 を追加。最近使用したアプリを dock に追加しないよう設定。
  finder での並び順を常に種類順に。
  タッチによるクリックを有効化。
  capslock に control を割り当て。
  command+option+J で iterm2 を起動するようにした。Automator を使った。
  ターミナル   iterm2 に hybrid-material のカラースキームを適用。</description>
			<content type="html"><![CDATA[<h1 id="dotfiles">dotfiles</h1>
<ul>
<li>
<p>brew のインスコ-&gt;brew install git-&gt;git clone-&gt;brew bundle の流れ。ちなみに git 自体は元から入っていた。</p>
</li>
<li>
<p>brew のインストールにめちゃ時間掛かってびっくりしてしまった。xcode も一緒に入れるらしくそこで時間吸われたっぽい。</p>
</li>
<li>
<p>brew bundle も永遠に終わらず、バイトに行く前に回し始めておいたのだが帰ってきたらエラー終了していた。llvm にやたら時間が掛かっていたっぽい。</p>
</li>
</ul>
<h1 id="neovim">neovim</h1>
<p>概ね問題なかったが、pip で neovim の何かを入れるのを忘れていて deoplete に怒られてしまった。</p>
<h1 id="mac-のシステム環境設定">mac のシステム環境設定</h1>
<ul>
<li>
<p>dock を右寄せ、自動的に非表示。使わないアプリを dock から消して iterm2 を追加。最近使用したアプリを dock に追加しないよう設定。</p>
</li>
<li>
<p>finder での並び順を常に種類順に。</p>
</li>
<li>
<p>タッチによるクリックを有効化。</p>
</li>
<li>
<p>capslock に control を割り当て。</p>
</li>
<li>
<p>command+option+J で iterm2 を起動するようにした。Automator を使った。</p>
</li>
</ul>
<h1 id="ターミナル">ターミナル</h1>
<ul>
<li>
<p>iterm2 に hybrid-material のカラースキームを適用。</p>
</li>
<li>
<p>zsh に移行。具体的には git の補完とか branch をプロンプトに表示する設定をした。これからやる人は vcs_info とかで調べると幸せになれそう。</p>
</li>
<li>
<p>ターミナルをリロードするスクリプトをエイリアスに割り当てた。.zshrc を書き換えまくるときの QOL が爆上がりする。</p>
</li>
</ul>
<h1 id="これからやりたいこと">これからやりたいこと</h1>
<ul>
<li>
<p>zsh のプロンプトに git の情報を載せるところをもう少しちゃんとやる(まだ branch 表示とコミットしてないファイルの検知しかできない)</p>
</li>
<li>
<p>lsp 周りをすっきりさせる。まあこれは buildin lsp を待とうかな。</p>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Codeforces Round 619</title>
			<link>https://mijinko17.github.io/hoge/posts/codefo_round_619/</link>
			<pubDate>Fri, 14 Feb 2020 01:33:04 +0900</pubDate>
			
			<guid>https://mijinko17.github.io/hoge/posts/codefo_round_619/</guid>
			<description>A a[i]、b[i]どちらかがc[i]と等しければ ok。
B k は-1 と隣接するものの内最大のものと最小のものの中間にするのが最適。
C 均等に分割する。
D 行ごとに頑張ると全ての道を通れる。
E 時間のなさ</description>
			<content type="html"><![CDATA[<h1 id="a">A</h1>
<p><code>a[i]</code>、<code>b[i]</code>どちらかが<code>c[i]</code>と等しければ ok。</p>
<h1 id="b">B</h1>
<p>k は-1 と隣接するものの内最大のものと最小のものの中間にするのが最適。</p>
<h1 id="c">C</h1>
<p>均等に分割する。</p>
<h1 id="d">D</h1>
<p>行ごとに頑張ると全ての道を通れる。</p>
<h1 id="e">E</h1>
<p>時間のなさ</p>
]]></content>
		</item>
		
		<item>
			<title>ABC154</title>
			<link>https://mijinko17.github.io/hoge/posts/abc154/</link>
			<pubDate>Sun, 09 Feb 2020 22:39:01 +0900</pubDate>
			
			<guid>https://mijinko17.github.io/hoge/posts/abc154/</guid>
			<description>Summary A はい
B string(s.size(),&#39;x&#39;)
C unordered_map で数え上げ
D 累積和
E 桁 dp。桁 dp の書き方に慣れてなくて苦戦
F 何もできなかった&amp;hellip; 結局答えは$f(r_1-1,k)$とか$f(l,c_1-1)$とかの線形和なのであとは係数を決めればいいがどうやればいいか分からなかった。
#Detail
D 見た瞬間累積和をする(尺取りでもいいが累積和の構造体を持ってるので累積和の方が楽)。小数が現れても高々 0.5 とかなので誤差を気にしなくても大丈夫だろうと考え特別な処理をせずに出すと WA を食らう。原因が分からなかったがとりあえずsetprecisionすると通る。
E $n$以下の自然数の時点で桁 dp 臭。桁に関する条件で凄まじい桁 dp 臭。以前の反省を踏まえ全探索できないか見るが制約的に今回ばかりはできない。桁 dp で確定。しかし書き方になれず大苦戦する。練習します……</description>
			<content type="html"><![CDATA[<h1 id="summary">Summary</h1>
<h2 id="a">A</h2>
<p>はい</p>
<h2 id="b">B</h2>
<p><code>string(s.size(),'x')</code></p>
<h2 id="c">C</h2>
<p>unordered_map で数え上げ</p>
<h2 id="d">D</h2>
<p>累積和</p>
<h2 id="e">E</h2>
<p>桁 dp。桁 dp の書き方に慣れてなくて苦戦</p>
<h2 id="f">F</h2>
<p>何もできなかった&hellip; 結局答えは$f(r_1-1,k)$とか$f(l,c_1-1)$とかの線形和なのであとは係数を決めればいいがどうやればいいか分からなかった。</p>
<p>#Detail</p>
<h2 id="d-1">D</h2>
<p>見た瞬間累積和をする(尺取りでもいいが累積和の構造体を持ってるので累積和の方が楽)。小数が現れても高々 0.5 とかなので誤差を気にしなくても大丈夫だろうと考え特別な処理をせずに出すと WA を食らう。原因が分からなかったがとりあえず<code>setprecision</code>すると通る。</p>
<h2 id="e-1">E</h2>
<p>$n$以下の自然数の時点で桁 dp 臭。桁に関する条件で凄まじい桁 dp 臭。以前の反省を踏まえ全探索できないか見るが制約的に今回ばかりはできない。桁 dp で確定。しかし書き方になれず大苦戦する。練習します……</p>
]]></content>
		</item>
		
		<item>
			<title>ABC153</title>
			<link>https://mijinko17.github.io/hoge/posts/abc153/</link>
			<pubDate>Sun, 26 Jan 2020 22:13:03 +0900</pubDate>
			
			<guid>https://mijinko17.github.io/hoge/posts/abc153/</guid>
			<description>ペナ込み 74 分全完でした。 典型の E で時間溶かしたの良くなかった……
問題: atcoder.jp/contests/abc153/tasks
成績: atcoder.jp/users/mijinko/history/share/abc153
Summary A 繰り上げの割り算でスッキリ書きます。
B 必殺技全部使って倒せれば十分。
C 強いモンスターを必殺技で殴って残ったやつを攻撃。
D $f(n):=$(体力$n$のやつを倒すための攻撃数)を dfs
E ダメージ合計を頂点とするグラフを作ってダイクストラで撲殺。そんなことせずともナップザックすればいいっぽいのだが何回でも同じ魔法を使えるところで頭がいかれてしまった。
F 生き残ってる最も左のモンスターを擦るように攻撃するのが最適。使った爆弾がどこまで影響するかをいもす法的に管理して左から見る。
 Details E 考えたのは
 ナップザック グラフを作ってダイクストラ  です。
問題文からしてナップザックを考えるのは当然なのですが、同じ魔法を何度も使える点が The ナップザック的な問題と少し違います。問題が簡単なのは気づきましたがそのせいで焦ってしまい冷静な思考を失ってしまいました。
たまたまこの手の問題をダイクストラで殴り殺した経験があり、その方向で考え直したらうまくいきました。
ダイクストラで解いた人が少ないようなので一応解法を簡単に書くと、ダメージ合計を頂点とするグラフを作り、$i$ から $i+A_j$ にコスト $B_j$ の有向辺を貼ります。このグラフで 0 を始点とするダイクストラをして $h$ までの距離を出力すればいいです。この解法はむしろ同じ魔法を何度も使用できるからこそ使える方法ですね。
提出したコードを貼っておきます。オーバーキル感はありますが、やること自体はシンプルで自分は好きです。
atcoder.jp/contests/abc153/submissions/9756498
あと実験としてここにも貼ります。
Eのソースコード #include &amp;lt;bits/stdc++.h&amp;gt;typedef long long lint; using namespace std; //ただの辺 struct edge { using lint = long long int; int to; lint cost; //引数一つの時は距離1  edge(int t, lint c = 1) : to(t), cost(c) { } }; lint h, n; vector&amp;lt;lint&amp;gt; a, b; // dijkstra // depend:edge vector&amp;lt;long long int&amp;gt; dijkstra(vector&amp;lt;vector&amp;lt;edge&amp;gt;&amp;gt;&amp;amp; g, int start) { using lint = long long int; vector&amp;lt;lint&amp;gt; res(g.</description>
			<content type="html"><![CDATA[<p>ペナ込み 74 分全完でした。
典型の E で時間溶かしたの良くなかった……</p>
<p>問題: <a href="https://atcoder.jp/contests/abc153/tasks" target="_blank">atcoder.jp/contests/abc153/tasks</a></p>
<p>成績: <a href="https://atcoder.jp/users/mijinko/history/share/abc153" target="_blank">atcoder.jp/users/mijinko/history/share/abc153</a></p>
<h1 id="summary">Summary</h1>
<h2 id="a">A</h2>
<p>繰り上げの割り算でスッキリ書きます。</p>
<h2 id="b">B</h2>
<p>必殺技全部使って倒せれば十分。</p>
<h2 id="c">C</h2>
<p>強いモンスターを必殺技で殴って残ったやつを攻撃。</p>
<h2 id="d">D</h2>
<p>$f(n):=$(体力$n$のやつを倒すための攻撃数)を dfs</p>
<h2 id="e">E</h2>
<p>ダメージ合計を頂点とするグラフを作ってダイクストラで撲殺。そんなことせずともナップザックすればいいっぽいのだが何回でも同じ魔法を使えるところで頭がいかれてしまった。</p>
<h2 id="f">F</h2>
<p>生き残ってる最も左のモンスターを擦るように攻撃するのが最適。使った爆弾がどこまで影響するかをいもす法的に管理して左から見る。</p>
<hr>
<h1 id="details">Details</h1>
<h2 id="e-1">E</h2>
<p>考えたのは</p>
<ul>
<li>ナップザック</li>
<li>グラフを作ってダイクストラ</li>
</ul>
<p>です。</p>
<p>問題文からしてナップザックを考えるのは当然なのですが、同じ魔法を何度も使える点が The ナップザック的な問題と少し違います。問題が簡単なのは気づきましたがそのせいで焦ってしまい冷静な思考を失ってしまいました。</p>
<p>たまたまこの手の問題をダイクストラで殴り殺した経験があり、その方向で考え直したらうまくいきました。</p>
<p>ダイクストラで解いた人が少ないようなので一応解法を簡単に書くと、ダメージ合計を頂点とするグラフを作り、$i$ から $i+A_j$ にコスト $B_j$ の有向辺を貼ります。このグラフで 0 を始点とするダイクストラをして $h$ までの距離を出力すればいいです。この解法はむしろ同じ魔法を何度も使用できるからこそ使える方法ですね。</p>
<p>提出したコードを貼っておきます。オーバーキル感はありますが、やること自体はシンプルで自分は好きです。</p>
<p><a href="https://atcoder.jp/contests/abc153/submissions/9756498" target="_blank">atcoder.jp/contests/abc153/submissions/9756498</a></p>
<p>あと実験としてここにも貼ります。</p>
<details><summary>Eのソースコード</summary><div>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">lint</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">//ただの辺
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">edge</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">lint</span> <span class="o">=</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">to</span><span class="p">;</span>
    <span class="n">lint</span> <span class="n">cost</span><span class="p">;</span>
    <span class="c1">//引数一つの時は距離1
</span><span class="c1"></span>    <span class="n">edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="n">lint</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">to</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">cost</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">lint</span> <span class="n">h</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">lint</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>

<span class="c1">// dijkstra
</span><span class="c1">// depend:edge
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">dijkstra</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">edge</span><span class="o">&gt;&gt;&amp;</span> <span class="n">g</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">lint</span> <span class="o">=</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">lint</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">LLONG_MAX</span><span class="p">);</span>
    <span class="n">res</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// first:距離、second:行き先
</span><span class="c1"></span>    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">lint</span><span class="p">,</span> <span class="n">lint</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">lint</span><span class="p">,</span> <span class="n">lint</span><span class="o">&gt;&gt;</span><span class="p">,</span>
                   <span class="n">greater</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">lint</span><span class="p">,</span> <span class="n">lint</span><span class="o">&gt;&gt;&gt;</span>
        <span class="n">pq</span><span class="p">;</span>
    <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">});</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">lint</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">first</span><span class="p">,</span> <span class="n">now</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
        <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">now</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">g</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">edge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">res</span><span class="p">[</span><span class="n">now</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">.</span><span class="n">cost</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">res</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">now</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">.</span><span class="n">cost</span><span class="p">;</span>
                <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">],</span> <span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">a</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">b</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">edge</span><span class="o">&gt;&gt;</span> <span class="n">g</span><span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">edge</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">h</span><span class="p">),</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dijkstra</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">0</span><span class="p">)[</span><span class="n">h</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div></details>
<p>想像以上に見辛くて笑っちゃいますね……。i がひどすぎる……</p>
<h2 id="f-1">F</h2>
<ul>
<li>遅延セグ木</li>
<li>いもす法</li>
</ul>
<p>を考えました。最終的にいもす法を用いましたが遅延セグ木でもできるようです。</p>
<p>左端(右端でも ok)のモンスターをギリギリ巻き込むように爆破するのが最適なのはすぐわかります。あとは範囲攻撃による処理を高速にやれば十分です。</p>
<p>範囲に関する処理として遅延セグ木を真っ先に考えましたが、自分の用意したセグ木がちゃんと使えるか自信がなくなり断念しました。ABC で遅延セグ木が出る筈がないというのもあります。</p>
<p>他の範囲系処理の方法としていもす法がありますが、考察を進めるといもす法で爆破範囲の右端を管理すれば十分だとわかります。一回 RE を挟みましたが落ち着いて修正して AC。</p>
<p>範囲処理の方法を冷静に吟味できたのは成長だと思います。</p>
]]></content>
		</item>
		
		<item>
			<title>Codeforces Round #615</title>
			<link>https://mijinko17.github.io/hoge/posts/codefo_round_615/</link>
			<pubDate>Thu, 23 Jan 2020 02:58:44 +0900</pubDate>
			
			<guid>https://mijinko17.github.io/hoge/posts/codefo_round_615/</guid>
			<description>A 一旦最大のものに合わせる。残ったコインが 3 の倍数なら YES。
B ソートして前から見る。次の目的地が右上になかったら NO
C 素因数が一つの時は指数が 6 以上で OK。2 つ以上の時は適当に素因数 2 つとって a、b に割り当てて c=n/(a*b)とする。
D x で割った余りで分類して、各余りごとに前から詰めるのが最適。各余りについて作られない最小の数を計算して、それらの最小値を計算すれば良い。セグ木でぶん殴って終わり。
E 各列で考える。各回転数についてどのくらい目的の状態と一致するか分かればいい。各$a_{ij}$について何回転すれば最適な位置に移動できるかはすぐわかることを利用すれば$O(n)$で計算できる。ランタイムエラーで通らなくて切れる。
F 無証明だが多分木の直径の両端とあと一つ最適なやつを取ればいい。三つ目をとるときに LCA でぶん殴る。</description>
			<content type="html"><![CDATA[<h2 id="a">A</h2>
<p>一旦最大のものに合わせる。残ったコインが 3 の倍数なら YES。</p>
<h2 id="b">B</h2>
<p>ソートして前から見る。次の目的地が右上になかったら NO</p>
<h2 id="c">C</h2>
<p>素因数が一つの時は指数が 6 以上で OK。2 つ以上の時は適当に素因数 2 つとって a、b に割り当てて c=n/(a*b)とする。</p>
<h2 id="d">D</h2>
<p>x で割った余りで分類して、各余りごとに前から詰めるのが最適。各余りについて作られない最小の数を計算して、それらの最小値を計算すれば良い。セグ木でぶん殴って終わり。</p>
<h2 id="e">E</h2>
<p>各列で考える。各回転数についてどのくらい目的の状態と一致するか分かればいい。各$a_{ij}$について何回転すれば最適な位置に移動できるかはすぐわかることを利用すれば$O(n)$で計算できる。ランタイムエラーで通らなくて切れる。</p>
<h2 id="f">F</h2>
<p>無証明だが多分木の直径の両端とあと一つ最適なやつを取ればいい。三つ目をとるときに LCA でぶん殴る。</p>
]]></content>
		</item>
		
		<item>
			<title>ABC152</title>
			<link>https://mijinko17.github.io/hoge/posts/abc152/</link>
			<pubDate>Mon, 20 Jan 2020 06:55:14 +0900</pubDate>
			
			<guid>https://mijinko17.github.io/hoge/posts/abc152/</guid>
			<description>94 分 A~E の 5 完でした。
D に 50 分くらい吸われて死にかけましたが何とか E まで解けました。毎度 C、D あたりで引っかかってる気がします。
問題: https://atcoder.jp/contests/abc152/tasks
成績: https://atcoder.jp/users/mijinko/history/share/abc152
A N==Mかを判定すればいいです。
B  string(n,c)で char c を n 個くっつけたものを生成できるので文字列の生成はすぐです。 string に対して不等号を使えば辞書順の判定はできるのでこれで終わりです。  C  「前にある数が全て自分より大きい」ような数の個数を数えればいいです。 これは「前にある数の最小値が自分より大きい」ような数と言い換えられます。 先頭から順に見ていく場合、前にある数の集合は 1 つずつ増えていきます。これに合わせて min を更新していけばいいです。  D  「n 以下の整数で〜」かつ桁に関する情報と来たら桁 dp。当然ですね。 桁 dp あんま書いたことなくて何も分からない…… 桁 dp でググったりしたけど結局どう dp をするのか分からないまま時間が流れます。 とりあえず問題文を読んで求めたいものを整理します。先頭が i、最後尾が j なる数の総数が分かれば良さそうです。これをcount[i][j]という形で持つことにします。 各(i,j)について高速に count を計算できそうです。i が n の最高位より小さかったら〜、等しい時は j が n の一の位より大きかったら〜…… そんな複雑なコードでバグらないわけがありません(破滅)。この時点で 50 分が経過し 3 完を覚悟します。 ここで 1〜n まで全部見て count を完成させる方法が降って来ます。危なかった。整数 k の最高位と最下位はs=to_string(k)としてs[0]、s.</description>
			<content type="html"><![CDATA[<p>94 分 A~E の 5 完でした。</p>
<p>D に 50 分くらい吸われて死にかけましたが何とか E まで解けました。毎度 C、D あたりで引っかかってる気がします。</p>
<p>問題: <a href="https://atcoder.jp/contests/abc152/tasks">https://atcoder.jp/contests/abc152/tasks</a></p>
<p>成績: <a href="https://atcoder.jp/users/mijinko/history/share/abc152">https://atcoder.jp/users/mijinko/history/share/abc152</a></p>
<h1 id="a">A</h1>
<p><code>N==M</code>かを判定すればいいです。</p>
<h1 id="b">B</h1>
<ol>
<li><code>string(n,c)</code>で char c を n 個くっつけたものを生成できるので文字列の生成はすぐです。</li>
<li>string に対して不等号を使えば辞書順の判定はできるのでこれで終わりです。</li>
</ol>
<h1 id="c">C</h1>
<ol>
<li>「前にある数が全て自分より大きい」ような数の個数を数えればいいです。</li>
<li>これは「前にある数の最小値が自分より大きい」ような数と言い換えられます。</li>
<li>先頭から順に見ていく場合、前にある数の集合は 1 つずつ増えていきます。これに合わせて min を更新していけばいいです。</li>
</ol>
<h1 id="d">D</h1>
<ol>
<li>「n 以下の整数で〜」かつ桁に関する情報と来たら桁 dp。当然ですね。</li>
<li>桁 dp あんま書いたことなくて何も分からない…… 桁 dp でググったりしたけど結局どう dp をするのか分からないまま時間が流れます。</li>
<li>とりあえず問題文を読んで求めたいものを整理します。先頭が i、最後尾が j なる数の総数が分かれば良さそうです。これを<code>count[i][j]</code>という形で持つことにします。</li>
<li>各(i,j)について高速に count を計算できそうです。i が n の最高位より小さかったら〜、等しい時は j が n の一の位より大きかったら〜……</li>
<li>そんな複雑なコードでバグらないわけがありません(破滅)。この時点で 50 分が経過し 3 完を覚悟します。</li>
<li>ここで 1〜n まで全部見て count を完成させる方法が降って来ます。危なかった。整数 k の最高位と最下位は<code>s=to_string(k)</code>として<code>s[0]</code>、<code>s.back()</code>で取得します。</li>
</ol>
<p>何を求められると良いか落ち着いて整理したおかげで辛うじて軌道修正できました。</p>
<p>今思えば<a href="https://atcoder.jp/contests/abc136/tasks/abc136_b">この問題</a>とやることはほぼ同じですね……以前これに殺されかけたのに何故……</p>
<h1 id="e">E</h1>
<ol>
<li>$n \leq 10^4$ の制約がとても不吉。$O(n^2)$ がギリギリ間に合うくらいです。</li>
<li>問題文をよく読むと$\{A_i\}$の lcm を求めろと書いてあります。なのでとりあえず lcm を計算する方法を考えます。</li>
<li>lcm の最も素直な計算方法は<code>lcm(a,b)=a/gcd(a,b)*b</code>を用いて前から計算していく方法ですが、今回の制約下では明らかに途中でオーバーフローします。今回は$\bmod\ 10^9+7$で答えればいいので途中で余りを取りながら計算して上手くいけばいいのですが、lcm の計算で本当にそんなことをしていいのでしょうか……。「最小公倍数　余り　競プロ」などで調べますがあまりいい情報は得られません。</li>
<li>詰みが見えてきたので実は F の方が簡単説に懸けて順位表を見にいきます。しかし F の正解者数はそこまで多くない一方で E が 700 人近くに解かれていて絶望します。これそんな簡単か……？</li>
<li>700 人も解いてるわけだし実は 3 の方針でいいんじゃないか？という気がしてきてとりあえず実装してみます。しかし当然ダメ……入力例 3 で合いません。終わりです。</li>
<li>実は k を決め打ったりすると良かったりしないか考えます。k を決めた時にそれが&quot;公倍数&quot;であることがそこそこの時間で判定できて、また何らかの単調性があれば二分探索で勝ちです。しかしやはり余りを取る操作と倍数という性質の相性が悪すぎてうまくいきません。</li>
<li>ここで突然 lcm を素因数分解の形で保持せよとの天啓が降って来ます(本当はこういう部分をしっかり書くべきなのに何故……)。必要なものは lcm を求めるための素因数分解、素因数分解から数を復元するための累乗、$B_i$を求めるための mod 逆元ですが、これらは幸い全てライブラリにあります。ライブラリに感謝。残り 6 分くらいに提出して何とか滑り込みます。</li>
</ol>
<p>通常の lcm の計算がダメだと気付いた時に別の計算方法がないかすぐに考えるべきでした。</p>
<h1 id="f">F</h1>
<p>時間がありません。</p>
]]></content>
		</item>
		
		<item>
			<title>Hello, World!</title>
			<link>https://mijinko17.github.io/hoge/posts/first_post/</link>
			<pubDate>Mon, 20 Jan 2020 03:11:20 +0900</pubDate>
			
			<guid>https://mijinko17.github.io/hoge/posts/first_post/</guid>
			<description>このサイトについて   このサイトは mijinko(twitter, atcoder)によって主に競技プログラミング関係の記事を投稿するために作られました。
  コンテスト後によく自分の解法をまとめたツイートをするのですが、この前コンテストに参加できなかった時に他の方の解法ツイートが目障りに感じました(すみませんやたら強い言葉を使ってるのは単純にいい表現が思いつかないだけです……)。コンテスト後の感想戦(?)も競プロの醍醐味ではあるのですが、twitter などの情報の取捨選択をしにくい場所にデカデカと解法を書き連ねるのは少し違うような気がしています。今後は自分の解法はここに投稿するつもりです。
  ページレイアウトは hugo のテンプレートを使って作成し、それを github pages で公開しています。テキストベースのものは極力 github で管理したい思いがあり、それを実現するには github pages が最適だという判断です。ちなみに以前は github pages のリポジトリは公開用とソースコード用で二つ用意したりブランチを不自然に切ったりする必要があったようですが、この記事を書いている現在は以下のように設定することで 1 つのリポジトリで綺麗に完結させることができます。
 github pages の source を master の docs/に指定する。 ./config.toml にpublishDir=&amp;quot;docs&amp;quot;を追加する。これで build 後の生成ファイルが docs/に出力されるようになる。  あと自分がサイトを作る時に悩んだことを書き残しておきます。
 無料アカウントの場合、github pages に使うリポジトリは public である必要があります。 以前は使うリポジトリの名前が固定されていたようですが、現在はどのリポジトリでも pages を使うことができます。    markdown の書き方が分からなすぎて辛いです。今日は結局リンクを別のタブで開くようにできませんでした。あと tex の表示もできるようにしたいですね。
  このページテーマは Hermit という名前で、スタイリッシュで気に入っているのですが、ページの遷移が悪い感があります。一つの記事から他のページへの移動がとても面倒です(一度記事一覧に戻る必要があります)。テーマは気軽に変えられそうなのでもう少し使い勝手のいいものを探していきます。
  </description>
			<content type="html"><![CDATA[<h1 id="このサイトについて">このサイトについて</h1>
<ul>
<li>
<p>このサイトは mijinko(<a href="https://twitter.com/mijinko_cpp">twitter</a>, <a href="https://atcoder.jp/users/mijinko">atcoder</a>)によって主に競技プログラミング関係の記事を投稿するために作られました。</p>
</li>
<li>
<p>コンテスト後によく自分の解法をまとめたツイートをするのですが、この前コンテストに参加できなかった時に他の方の解法ツイートが目障りに感じました(すみませんやたら強い言葉を使ってるのは単純にいい表現が思いつかないだけです……)。コンテスト後の感想戦(?)も競プロの醍醐味ではあるのですが、twitter などの情報の取捨選択をしにくい場所にデカデカと解法を書き連ねるのは少し違うような気がしています。今後は自分の解法はここに投稿するつもりです。</p>
</li>
<li>
<p>ページレイアウトは hugo のテンプレートを使って作成し、それを github pages で公開しています。テキストベースのものは極力 github で管理したい思いがあり、それを実現するには github pages が最適だという判断です。ちなみに以前は github pages のリポジトリは公開用とソースコード用で二つ用意したりブランチを不自然に切ったりする必要があったようですが、この記事を書いている現在は以下のように設定することで 1 つのリポジトリで綺麗に完結させることができます。</p>
<ul>
<li>github pages の source を master の docs/に指定する。</li>
<li>./config.toml に<code>publishDir=&quot;docs&quot;</code>を追加する。これで build 後の生成ファイルが docs/に出力されるようになる。</li>
</ul>
<p>あと自分がサイトを作る時に悩んだことを書き残しておきます。</p>
<ul>
<li>無料アカウントの場合、github pages に使うリポジトリは public である必要があります。</li>
<li>以前は使うリポジトリの名前が固定されていたようですが、現在はどのリポジトリでも pages を使うことができます。</li>
</ul>
</li>
<li>
<p>markdown の書き方が分からなすぎて辛いです。今日は結局リンクを別のタブで開くようにできませんでした。あと tex の表示もできるようにしたいですね。</p>
</li>
<li>
<p>このページテーマは Hermit という名前で、スタイリッシュで気に入っているのですが、ページの遷移が悪い感があります。一つの記事から他のページへの移動がとても面倒です(一度記事一覧に戻る必要があります)。テーマは気軽に変えられそうなのでもう少し使い勝手のいいものを探していきます。</p>
</li>
</ul>
]]></content>
		</item>
		
	</channel>
</rss>
