<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AtCoder on biotope monologue</title>
    <link>https://mijinko17.github.io/hoge/tags/atcoder/</link>
    <description>Recent content in AtCoder on biotope monologue</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Thu, 30 Apr 2020 21:30:34 +0900</lastBuildDate>
    
	<atom:link href="https://mijinko17.github.io/hoge/tags/atcoder/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>AtCoder青になったのでイキる</title>
      <link>https://mijinko17.github.io/hoge/posts/into_blue/</link>
      <pubDate>Thu, 30 Apr 2020 21:30:34 +0900</pubDate>
      
      <guid>https://mijinko17.github.io/hoge/posts/into_blue/</guid>
      <description>先日の ABC で念願の青コーダーになりました。
黄パフォで青に入れて気持ちよかったです。
この記事では青になるまでにやってきたことを書いてイキっていこうと思います。
何をした   アルゴリズム、データ構造の勉強をした(去年 8 月〜)
学んだアルゴリズムはだいたいここを見れば分かります。
青になった時点でのライブラリ
アルゴリズム習得の目的は次の 2 つです。
 解ける問題を増やす 知識不足で解けないかもしれない、という不安を払拭する  2 つ目が重要です。問題を解く上で「今の自分の知識では無理かも……」という精神状態になってしまうと解ける問題も解けません。これを回避したければ目にしがちなアルゴリズムは全て習得してしまうべきです。自分はこの考えのもとに緑の頃から遅延セグ木や FFT の勉強をしていました。
たまに twitter で「foo 色に bar アルゴリズムは必要ない！！」と主張してる人を見かけますが、上記の理由からアルゴリズムの学習はどのタイミングでやっても意味があると思っています。
具体的な学習方法についてですが、友人の友人が github で公開している競プロライブラリにあるアルゴリズムをググり、けんちょんさんの記事で勉強することが多かったです。
  ライブラリを整備した(去年 9 月〜)
目的は以下の 2 つです。
 ライブラリをぺたぺた貼って問題を瞬殺できるようにするため。 実装力の低さをカバーするため  これについてあまり語ることはありません。ちなみにライブラリはスニペットですぐ貼れるようにすると楽です。
  実験をするようにした(去年 9 月〜)
きっかけはつよつよの友人が凄まじい diff の問題を実験しまくって解くのを見たことだったと思います。当時水 diff すら怪しかった自分ですが、彼を真似して実験を大切にするようにしたら青 diff も解けるようになりました。
記述が少なくてやる気なさげに見えるかもしれませんが、自分が青になる上で一番効いたのは実験だと思ってます。実験は頭にイイ！！
  山を張った
「自分にはできない」という自信のなさを払拭する一度の成功体験が欲しくて山を張ったことがあります。具体的には以下の 2 回です。
  ABC の E を本番で解くためにグラフの問題に集中して取り組んだ(去年 10 月)</description>
    </item>
    
    <item>
      <title>ABC152</title>
      <link>https://mijinko17.github.io/hoge/posts/abc152/</link>
      <pubDate>Mon, 20 Jan 2020 06:55:14 +0900</pubDate>
      
      <guid>https://mijinko17.github.io/hoge/posts/abc152/</guid>
      <description>94 分 A~E の 5 完でした。
D に 50 分くらい吸われて死にかけましたが何とか E まで解けました。毎度 C、D あたりで引っかかってる気がします。
問題: https://atcoder.jp/contests/abc152/tasks
成績: https://atcoder.jp/users/mijinko/history/share/abc152
A N==Mかを判定すればいいです。
B  string(n,c)で char c を n 個くっつけたものを生成できるので文字列の生成はすぐです。 string に対して不等号を使えば辞書順の判定はできるのでこれで終わりです。  C  「前にある数が全て自分より大きい」ような数の個数を数えればいいです。 これは「前にある数の最小値が自分より大きい」ような数と言い換えられます。 先頭から順に見ていく場合、前にある数の集合は 1 つずつ増えていきます。これに合わせて min を更新していけばいいです。  D  「n 以下の整数で〜」かつ桁に関する情報と来たら桁 dp。当然ですね。 桁 dp あんま書いたことなくて何も分からない…… 桁 dp でググったりしたけど結局どう dp をするのか分からないまま時間が流れます。 とりあえず問題文を読んで求めたいものを整理します。先頭が i、最後尾が j なる数の総数が分かれば良さそうです。これをcount[i][j]という形で持つことにします。 各(i,j)について高速に count を計算できそうです。i が n の最高位より小さかったら〜、等しい時は j が n の一の位より大きかったら〜…… そんな複雑なコードでバグらないわけがありません(破滅)。この時点で 50 分が経過し 3 完を覚悟します。 ここで 1〜n まで全部見て count を完成させる方法が降って来ます。危なかった。整数 k の最高位と最下位はs=to_string(k)としてs[0]、s.</description>
    </item>
    
  </channel>
</rss>